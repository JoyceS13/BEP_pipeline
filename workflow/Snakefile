# Main entrypoint of the workflow. 
# Please follow the best practices: 
# https://snakemake.readthedocs.io/en/stable/snakefiles/best_practices.html,
# in particular regarding the standardized folder structure mentioned there. 

## some variables that might be nice to define at the top of the document -> put in config file
#general variables, maybe move to config file
reference = "IMBvariant/reference/chromosomes/CEN.PK113-7D_chr01_pilon.fa"
name = "chr1"
mutations = 200
repeats = 10
f_cov = [20,20]

#dependent global variables
repeat_ar = np.linspace(0,repeats-1,repeats)
props = "_".join(f_cov)
pop_size = len(f_cov)
pop_size_ar = np.linspace(0,pop_size-1,pop_size)
outdir = f"output/{name}_{mutations}mut_{props}fcov"
prefix = f"{name}_{mutations}mut_{pop_size}_pop"

#rule all:

#mutate reference sequence
rule mutate:
	input:
		"{scripts/mutator.py}",
	  	reference,
	  	mutations,
	  	popsize,
 	output:
	  	expand("{outdir}/sample{ii}/seq_{jj}.fasta", jj = pop_size_ar)
	params:
		out_prefix = "seq"
	conda:
		"envs/mutate_env.yaml"
  	shell:
	  	"python {input} -o params.out_prefix"
	

#simulate reads from mutated sequences
##needs to be altered so it can be used for different proportions and different population sizes
rule make_samples:
  	input:
	  	expand("{outdir}/sample{ii}/seq_{jj}.fasta", jj = pop_size_ar)
  	output:
	  	temp(expand("{outdir}/sample{ii}/seq_{jj}_{read_end}.fq", jj = pop_size_ar, read_end = [1,2]))
	params:
		out_prefix = {prefix}_{jj}_,
		f_cov = f_cov
	conda:
		"envs/art.yaml"
  	run:
		for ii in pop_size_ar:
    			shell("art_illumina -sam -i {input[ii]} -p -l 150 -ss HS25 -f {params.f_cov[ii]} -m 200 -s 10 -o {params.out_prefix}")

#group reads such that a certain population size is simulated 
rule group_reads:
  	input:
	  	reads1 = "{outdir}/sample{ii}/seq_{jj}_1.fq", jj = pop_size_ar,
		reads2 = "{outdir}/sample{ii}/seq_{jj}_2.fq", jj = pop_size_ar
	output:
		expand("{outdir}/sample{ii}/reads{read_end}.fq, read_end = [1,2])
	shell:
		"cat input.reads1 > reads1.fq"
		"cat input.reads2 > reads2.fq"
		

rule bwa_map:
  	input:
	  	reference,
	  	expand("{outdir}/sample{ii}/reads{read_end}.fq, read_end = [1,2])
  	output:
	  	"{outdir}/sample{ii}/aln.srt.bam"
	conda:
		"envs/bwa_map_env.yaml"
  	shell:
	  	"bwa mem {input} | samtools view -1 - | samtools sort - > {output}"

rule bcftools_call:
	input: 
		reference,
		"{outdir}/sample{ii}/aln.sort.bam"
	output:
		"{outdir}/sample{ii}/vcf/bcftools.vcf"
	params:
		ploidy = pop_size
	conda:
		"envs/bcftools.yaml"
	shell:
		"bcftools mpileup -f {input} | bcftools call --ploidy params.ploidy -m -o {output}"

rule bcftools_limit:
	input: 
		reference,
		"{outdir}/sample{ii}/aln.sort.bam"
	output:
		"{outdir}/sample{ii}/vcf/bcftools_limit.vcf"
	params:
		ploidy = 5
	conda:
		"envs/bcftools.yaml"
	shell:
		"bcftools mpileup -f {input} | bcftools call --ploidy params.ploidy -m -o {output}"

rule varscan_call:
	input: 
		reference,
		"{outdir}/sample{ii}/aln.sort.bam"
	output:
		"{outdir}/sample{ii}/vcf/varscan.vcf"
	conda:
		"envs/varscan.yaml"
	shell:
		"samtools mpileup -f {input} | varscan mpileup2snp - > {output} --output-vcf 1"

rule freebayes_call:
	input: 
		reference,
		"{outdir}/sample{ii}/aln.sort.bam"
	output:
		"{outdir}/sample{ii}/vcf/freebayes.vcf"
	conda:
		"envs/freebayes.yaml"
	shell:
		"freebayes -f {input[0]} -p 1 {input[1]} > {output}"
	
rule seq2msa:
	input:
		reference,
		"{outdir}/sample{ii}/seq{jj}.fasta"
	output:
		temp("{outdir}/sample{ii}/msa/msa_seq{jj}.msa")
	conda:
		"envs/snp-sites.yaml"
	shell:
		"cat {input} > {output}"

rule msa2vcf:
	input: 
		"{outdir}/sample{ii}/msa/msa_seq{jj}.msa"
	output:
		"{outdir}/sample{ii}/vcf/true_vcf_seq{jj}.vcf"
	shell:
		"snp-sites -v -o {output} {input}


